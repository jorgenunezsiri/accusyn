<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>A web-based genome synteny browser</title>
  <script type="text/javascript" src="circos.js"></script>
  <script type="text/javascript" src="d3.js"></script>
  <script type="text/javascript" src="d3-queue.js"></script>

  <script type="text/javascript" src="lodash.js"></script>
  <style type="text/css">
    /* No style rules here yet */
  </style>
</head>

<body>
  <div id="config" style="display: none; float: left">
    <p>
      <label for="nAngle" style="display: inline-block; text-align: left; width: 85px">
       rotate = <span id="nAngle-value">…</span>
      </label>
      <input type="range" min="0" max="360" id="nAngle">
    </p>
    <form id="form-config" onsubmit="event.preventDefault(); checkForm(this);">
    </form>
  </div>

  <script type="text/javascript">
    // TODO: clean everything and add comments

    var selectedCheckbox = []; // array that will store the value of selected checkboxes
    var showAllChromosomes = true;
    var gffPositionDictionary = {};
    var geneDictionary = {};
    var blockDictionary = {};
    var gffKeys = [];
    var gffFile;
    var collinearityFile;
    var dataChords = [];

    var myCircos;
    var svg;
    var width;
    var height;


    function checkForm(form) {
      selectedCheckbox = [];
      showAllChromosomes = false;
      // gets all the input tags in form
      var inputFields = form.getElementsByTagName('input');
      // traverse the input fields elements, and adds the value of each selected checkbox
      for (var i = 0; i < inputFields.length; i++) {
        if (inputFields[i].type == 'checkbox' && inputFields[i].checked == true) {
          inputFields[i].checked = false;
          if (inputFields[i].name == 'show-all') {
            showAllChromosomes = true;
          } else {
            selectedCheckbox.push(inputFields[i].value);
          }
        }
      }

      generateVisualization();
    }

    function generateData(error, gff, collinearity) {
      if (error) return console.error(error);
      gffFile = gff;
      collinearityFile = collinearity;

      console.log('GFF: ', gff);
      console.log('collinearity: ', collinearity);


      for (var i = 0; i < gff.length; i++) {
        if (gff[i].chrom.startsWith('Scaffold')) continue;
        var start = parseInt(gff[i].start);
        var end = parseInt(gff[i].end);

        if (!(gff[i].chrom in gffPositionDictionary)) {
          gffPositionDictionary[gff[i].chrom] = {};
          gffPositionDictionary[gff[i].chrom].start = start;
        }

        gffPositionDictionary[gff[i].chrom].end = end;
        geneDictionary[gff[i].gene] = {
          start: start,
          end: end
        }
      }

      width = 850;
      height = 850;

      gffKeys = Object.keys(gffPositionDictionary);
      gffKeys.sort(function compare(a, b) {
        a = parseInt(a.split('N')[1]);
        b = parseInt(b.split('N')[1]);
        if (a < b)
          return -1;
        if (a > b)
          return 1;
        return 0;
      });

      for (var i = 0; i < collinearityFile.length; i++) {
        var currentBlock = collinearityFile[i].block;

        if (!(currentBlock in blockDictionary)) {
          blockDictionary[currentBlock] = [];
        }

        blockDictionary[currentBlock].push({
          connection: collinearityFile[i].connection,
          source: collinearityFile[i].source,
          target: collinearityFile[i].target
        });
      }

      console.log("Block dictionary: ", blockDictionary["45"]);

      d3.select("#config")
        .style("display", "block")
        .style("width", width / 2 + 'px');

      d3.select("#form-config")
        .append('p')
        .attr('class', 'show-all')
        .append('input')
        .attr('type', 'checkbox')
        .attr('name', "show-all")
        .attr('value', "Show All")
        .attr('checked', "true");

      d3.select("#form-config").select('p.show-all')
        .append('span')
        .text(function() {
          return "Show All"
        });

      d3.select("#form-config").selectAll('p:not(.show-all)')
        .data(gffKeys).enter()
        .append('p')
        .append('input')
        .attr('type', 'checkbox')
        .attr('name', function(d) {
          return d;
        })
        .attr('value', function(d) {
          return d;
        });

      d3.select("#form-config").selectAll('p:not(.show-all)')
        .append('span')
        .text(function(d) {
          if (d) {
            return d.toString();
          }
        });

      d3.select("#form-config")
        .append('p')
        .append('input')
        .attr('type', 'submit');

      console.log('DICTIONARY gff: ', gffPositionDictionary);
      console.log('gene: ', geneDictionary['BnaN01g00190.1']);

      svg = d3.select("body")
        .append("div")
        .attr('id', 'chart')
        .attr("width", width)
        .attr("height", height)
        .style("float", "left");

      svg.select("svg > .all")
        .call(d3.zoom().on("zoom", function() {
          svg.select("svg > .all").attr("transform", d3.event.transform)
        }))
        .append("g");

      myCircos = new Circos({
        container: '#chart',
        width: width,
        height: height
      });


      generateVisualization();
    }

    function generateVisualization() {
      if (selectedCheckbox.length < 1) {
        selectedCheckbox = ["N1"];
      }
      // selectedCheckbox = selectedCheckbox == [] ? ["N1"] :;

      var data = [];
      var colors = d3.scaleOrdinal(d3.schemeCategory10);

      gffKeys.forEach(function(key, i) {
        // TODO: Only add the chromosomes selected
        // TODO: Add select all button
        if (gffPositionDictionary.hasOwnProperty(key)) {
          var currentObj = {
            len: gffPositionDictionary[key].end,
            color: colors(i),
            label: key,
            id: key
          };

          if (showAllChromosomes) {
            data.push(currentObj);
          } else {
            if (selectedCheckbox.indexOf(key) > -1) {
              data.push(currentObj);
            }
          }
        }
      });

      console.log('DATA: ', data);

      var configuration = {
        innerRadius: 300,
        outerRadius: 350,
        cornerRadius: 1,
        gap: data.length === 1 ? 0 : 0.04, // in radian
        labels: {
          display: true,
          position: 'center',
          size: '12px',
          color: '#000000',
          radialOffset: 20,
        },
        ticks: {
          display: false
        },
        events: {
          'click': function(d, i, nodes, event) {
            d3.select(nodes[i]).attr("opacity", 0.5);

            var trackContainers = myCircos.svg.selectAll('.all > g');

            // console.log('CONTAINERS: ', trackContainers);

            /*myCircos.svg.selectAll('tile')
              .data((d) => {
                console.log(d);
              })
              .enter().append('path')
              .attr('class', 'tile')
              .attr('d', function (d) {
                  console.log('D here: ', d);
              })*/
            //d.len = 200;
            console.log('clicked on layout block', d, i, nodes[i], event);
          }
        }
      };

      myCircos.layout(data, configuration);

      dataChords = [];

      /**
       * e.g. Fixes N1 to N01
       **/
      function fixStringNumbersLessThan10(str) {
        if (str.length == 2) return str[0] + "0" + str[1];
        return str;
      }

      /**
       *
       **/
      function fixSourceTargetCollinearity(collinearityFile) {
        var sourceID = collinearityFile[i].source.split("g")[0].split("Bna")[1];
        var targetID = collinearityFile[i].target.split("g")[0].split("Bna")[1];
        if (sourceID[1] == '0') {
          sourceID = sourceID.slice(0, 1) + sourceID.slice(2);
        }
        if (targetID[1] == '0') {
          targetID = targetID.slice(0, 1) + targetID.slice(2);
        }

        return {
          source: sourceID,
          target: targetID
        }
      }

      function lookForBlocksPositions (block) {
        var blockArray = blockDictionary[block];
        // TODO: Another way to declare these?
        var maxSource = 0;
        var minSource = 100000000;
        var maxTarget = 0;
        var minTarget = 100000000;
        for (var i = 0; i < blockArray.length; i++) {
          var currentSource = geneDictionary[blockArray[i].source];
          var currentTarget = geneDictionary[blockArray[i].target];

          if (currentSource.start < minSource) minSource = currentSource.start;
          if (currentSource.end > maxSource) maxSource = currentSource.end;

          if (currentTarget.start < minTarget) minTarget = currentTarget.start;
          if (currentTarget.end > maxTarget) maxTarget = currentTarget.end;
        }

        return {
          blockLength: blockArray.length,
          minSource: minSource,
          maxSource: maxSource,
          minTarget: minTarget,
          maxTarget: maxTarget
        }
      }

      console.log(lookForBlocksPositions(45));

      console.log(selectedCheckbox);
      var visited = []; // TODO: Fix this
      for (var i = 0; i < 1500; i++) {
        visited.push(false);
      }

      var oneToMany = selectedCheckbox.length == 1;
      for (var i = 0; i < collinearityFile.length; i++) {
        if (collinearityFile[i].source.includes('N') && collinearityFile[i].target.includes('N')) {

          var IDs = fixSourceTargetCollinearity(collinearityFile);
          var sourceID = IDs.source;
          var targetID = IDs.target;

          //console.log('SOURCE: ', sourceID);
          //console.log('TARGET: ', targetID);

          var lookID = [];
          var shouldAddDataChord = false;
          if (oneToMany) {
            lookID.push(selectedCheckbox[0]);
            //console.log('lookID: ', lookID);
            lookID[0] = fixStringNumbersLessThan10(lookID[0]);
            // I'm adding the extra 0 here with the function above
            shouldAddDataChord = collinearityFile[i].source.includes(lookID[0]);
            if (shouldAddDataChord) {
              // console.log(collinearityFile[i].source);
            }

            /*if (sourceID == "N1" && targetID == "N3" || targetID == "N1" && sourceID == "N3") {
              console.log ('HERE I AM !!!', lookID, sourceID, targetID);
            }*/


            // I'm looking the exact match here !!
            // shouldAddDataChord = lookID.indexOf(sourceID) > -1;
            // UNDERSTAND BETTER THE LOGIC HERE !!!
          } else {

            for (var j = 0; j < selectedCheckbox.length; j++) {
              lookID.push(selectedCheckbox[j]);
            }
            // Working now ... clean everything ... take things outside loop

            /*if (sourceID == "N1" && targetID == "N3" || targetID == "N1" && sourceID == "N3") {
               console.log ('HERE I AM !!!', lookID, sourceID, targetID);
            } */
            shouldAddDataChord = lookID.indexOf(sourceID) > -1 && lookID.indexOf(targetID) > -1;
            //console.log ('HERE I AM !!!', shouldAddDataChord);
          }

          var currentBlock = collinearityFile[i].block;
          if (!visited[currentBlock]) {
            var blockPositions = lookForBlocksPositions(currentBlock);

            visited[currentBlock] = true;
            if (shouldAddDataChord) {
              dataChords.push({
                source: {
                  id: sourceID,
                  start: blockPositions.minSource,
                  end: blockPositions.maxSource,
                  value: blockPositions.blockLength
                },
                target: {
                  id: targetID,
                  start: blockPositions.minTarget,
                  end: blockPositions.maxTarget,
                  value: blockPositions.blockLength
                }
              });
            }
          }

          /*if (shouldAddDataChord) {
            dataChords.push({
              source: {
                id: sourceID,
                start: geneDictionary[collinearityFile[i].source].start,
                end: geneDictionary[collinearityFile[i].source].end
              },
              target: {
                id: targetID,
                start: geneDictionary[collinearityFile[i].target].start,
                end: geneDictionary[collinearityFile[i].target].end
              }
            });
          }*/

        }
      }

      console.log('DATA CHORDS: ', dataChords.length);


      /* dataChords = [{
        source: {
          id: 'N1',
          start: 696,
          end: 2800000
        },
        target: {
          id: 'N16',
          start: 14800,
          end: 20000000
        }
      }];*/

      // var configurationChords = ;

      myCircos.chords('chords', dataChords, {
        radius: function(d) {
          return null;
        },
        logScale: false,
        opacity: 0.7,
        color: function(d) {
          /*if (d.source.value) {
            return d.source.value;
          } else*/
          return '#ff5722';
        },
        tooltipContent: function(d) {
          return '<h3>' + d.source.id + ' ➤ ' + d.target.id + '</h3><br /><h2>Block length: ' + d.source.value + '</h2>';
        },
        events: {
          'mouseover.demo': function(d, i, nodes, event) {
            console.log(d, i, nodes, event.pageX)
          }
        }
      });

      myCircos.render();

      /*svg.select(".all")
        .on("scroll", function(d) {
          console.log('hello: ', d);
        })*/

      d3.select("#nAngle").on("input", function() {
        update(+this.value);
      });

      // Initial starting angle of the text
      update(0);

      // update the element
      function update(nAngle) {

        // adjust the text on the range slider
        d3.select("#nAngle-value").text(nAngle + String.fromCharCode(176));
        d3.select("#nAngle").property("value", nAngle);

        // rotate the text
        svg.select(".all")
          .attr("transform", "translate(" + width / 2 + "," + height / 2.33 + ") rotate(" + -nAngle + ")");
      }
    }

    d3.queue()
      .defer(d3.csv, './files/gff.csv')
      .defer(d3.csv, './files/collinearity.csv')
      .await(generateData)
  </script>
</body>

</html>
