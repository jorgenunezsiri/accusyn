<!DOCTYPE html>

<!--
A web-based genome synteny browser

Name: Jorge Nunez Siri
NSID: jdn766
Student ID: 11239727
-->

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>A web-based genome synteny browser</title>
  <script type="text/javascript" src="circos.js"></script>
  <script type="text/javascript" src="d3.js"></script>
  <script type="text/javascript" src="d3-scale-chromatic.js"></script>
  <script type="text/javascript" src="d3-queue.js"></script>

  <script type="text/javascript" src="lodash.js"></script>
  <style type="text/css">
    #form-config p {
      color: black;
    }

    #form-config p.disabled {
      color: gainsboro;
    }

    .line {
      fill: none;
      stroke: peru;
      /* stroke-width: 2px; */
    }

    .axisBlue {
      fill: lightblue;
    }

    .axisGreen {
      fill: lightgreen;
    }

    .zoom {
      fill: none;
    }
  </style>
</head>

<body>
  <div id="config" style="display: none; float: left">
    <p>
      <label for="nAngle" style="display: inline-block; text-align: left; width: 85px">
       rotate = <span id="nAngle-value">…</span>
      </label>
      <input type="range" min="0" max="360" id="nAngle">
    </p>
    <form id="form-config" onsubmit="event.preventDefault(); checkForm(this);">
    </form>
  </div>

  <script type="text/javascript">
    // TODO: clean everything and add comments

    var selectedCheckbox = []; // array that will store the value of selected checkboxes
    var showAllChromosomes = true;
    var gffPositionDictionary = {};
    var geneDictionary = {};
    var connectionDictionary = {};
    var blockDictionary = {};
    var gffKeys = [];
    var gffFile;
    var collinearityFile;
    var dataChords = [];

    var myCircos;
    var svg;
    var width;
    var height;

    /**
     * [checkForm description]
     * @param  {[type]} form [description]
     * @return {[type]}      [description]
     */
    function checkForm(form) {
      d3.selectAll(".chr-box").each(function(d) {
        d3.select(this).attr("disabled", null);
        d3.select(this.parentNode).classed("disabled", false);
        d3.select(this.parentNode).select('span').text(d);
      });

      selectedCheckbox = [];
      showAllChromosomes = false;
      // gets all the input tags in form
      var inputFields = form.getElementsByTagName('input');
      // traverse the input fields elements, and adds the value of each selected checkbox
      for (var i = 0; i < inputFields.length; i++) {
        if (inputFields[i].type == 'checkbox' && inputFields[i].checked == true) {
          if (inputFields[i].name == 'show-all') {
            showAllChromosomes = true;
          } else {
            inputFields[i].checked = false;
            selectedCheckbox.push(inputFields[i].value);
          }
        }
      }

      generateGenomeView();
    }

    /**
     * [fixSourceTargetCollinearity description]
     * @param  {[type]} collinearityFile [description]
     * @param  {[type]} index            [description]
     * @return {[type]}                  [description]
     */
    function fixSourceTargetCollinearity(collinearityFile, index) {
      var sourceID = collinearityFile[index].source.split("g")[0].split("Bna")[1];
      var targetID = collinearityFile[index].target.split("g")[0].split("Bna")[1];
      if (sourceID[1] == '0') {
        sourceID = sourceID.slice(0, 1) + sourceID.slice(2);
      }
      if (targetID[1] == '0') {
        targetID = targetID.slice(0, 1) + targetID.slice(2);
      }

      return {
        source: sourceID,
        target: targetID
      }
    }

    /**
     * [findBlockConnection description]
     * @param  {[type]} dictionary [description]
     * @param  {[type]} source     [description]
     * @param  {[type]} target     [description]
     * @return {[type]}            [description]
     */
    function findBlockConnection(dictionary, source, target) {
      return dictionary[source].find(function(element) {
        return element.connection == target;
      });
    }

    /**
     * [findIndexConnection description]
     * @param  {[type]} dictionary [description]
     * @param  {[type]} source     [description]
     * @param  {[type]} target     [description]
     * @return {[type]}            [description]
     */
    function findIndexConnection(dictionary, source, target) {
      return dictionary[source].findIndex(function(element) {
        return element.connection == target;
      });
    }

    /**
     * [generateData description]
     * @param  {[type]} error        [description]
     * @param  {[type]} gff          [description]
     * @param  {[type]} collinearity [description]
     * @return {[type]}              [description]
     */
    function generateData(error, gff, collinearity) {
      if (error) return console.error(error);
      gffFile = gff;
      collinearityFile = collinearity;

      console.log('GFF: ', gff);
      console.log('collinearity: ', collinearity);

      for (var i = 0; i < gff.length; i++) {
        if (gff[i].chrom.startsWith('Scaffold')) continue;
        var start = parseInt(gff[i].start);
        var end = parseInt(gff[i].end);

        if (!(gff[i].chrom in gffPositionDictionary)) {
          gffPositionDictionary[gff[i].chrom] = {};
          gffPositionDictionary[gff[i].chrom].start = start;
        }

        gffPositionDictionary[gff[i].chrom].end = end;
        geneDictionary[gff[i].gene] = {
          start: start,
          end: end
        }
      }

      width = 800;
      height = 800;

      gffKeys = Object.keys(gffPositionDictionary);
      gffKeys.sort(function compare(a, b) {
        a = parseInt(a.split('N')[1]);
        b = parseInt(b.split('N')[1]);
        if (a < b) return -1;
        if (a > b) return 1;
        return 0;
      });

      blockDictionary = {};
      connectionDictionary = {};
      for (var i = 0; i < collinearityFile.length; i++) {
        if (collinearityFile[i].source.includes('N') && collinearityFile[i].target.includes('N')) {
          var currentBlock = collinearityFile[i].block;

          if (!(currentBlock in blockDictionary)) {
            blockDictionary[currentBlock] = [];
          }

          blockDictionary[currentBlock].push({
            connection: collinearityFile[i].connection,
            source: collinearityFile[i].source,
            target: collinearityFile[i].target
          });

          var IDs = fixSourceTargetCollinearity(collinearityFile, i);
          var sourceID = IDs.source;
          var targetID = IDs.target;

          if (!(sourceID in connectionDictionary)) {
            connectionDictionary[sourceID] = [];
          }

          if (!(targetID in connectionDictionary)) {
            connectionDictionary[targetID] = [];
          }

          var indexConnection = 0;
          if (!findBlockConnection(connectionDictionary, sourceID, targetID)) {
            connectionDictionary[sourceID].push({
              blockIDs: [currentBlock],
              connection: targetID,
              connectionAmount: 1
            });
          } else {
            indexConnection = findIndexConnection(connectionDictionary, sourceID, targetID);
            connectionDictionary[sourceID][indexConnection].connectionAmount++;

            if (connectionDictionary[sourceID][indexConnection].blockIDs.indexOf(currentBlock) === (-1)) {
              connectionDictionary[sourceID][indexConnection].blockIDs.push(currentBlock);
            }
          }

          if (!findBlockConnection(connectionDictionary, targetID, sourceID)) {
            connectionDictionary[targetID].push({
              blockIDs: [currentBlock],
              connection: sourceID,
              connectionAmount: 1
            });
          } else {
            var indexConnection = findIndexConnection(connectionDictionary, targetID, sourceID);

            if (targetID != connectionDictionary[targetID][indexConnection].connection) {
              connectionDictionary[targetID][indexConnection].connectionAmount++;
              // connectionDictionary[targetID][indexConnection].blockAmount = blockDictionary[currentBlock].length;
            }

            if (connectionDictionary[targetID][indexConnection].blockIDs.indexOf(currentBlock) === (-1)) {
              connectionDictionary[targetID][indexConnection].blockIDs.push(currentBlock);
            }
          }
        }
      }

      console.log('Connection dictionary: ', connectionDictionary);

      console.log("Block dictionary: ", blockDictionary["45"]);

      d3.select("#config")
        .style("display", "block")
        .style("margin-left", '10px')
        .style("width", width / 3.5 + 'px');

      d3.select("#form-config")
        .append('p')
        .attr('class', 'show-all')
        .append('input')
        .attr('type', 'checkbox')
        .attr('name', "show-all")
        .attr('value', "Show All")
        .attr('checked', true);

      d3.select("#form-config").select('p.show-all')
        .append('span')
        .text(function() {
          return "Show All";
        });

      d3.select("#form-config").selectAll('p:not(.show-all)')
        .data(gffKeys).enter()
        .append('p')
        .append('input')
        .attr('class', 'chr-box')
        .attr('type', 'checkbox')
        .attr('name', function(d) {
          return d;
        })
        .attr('value', function(d) {
          return d;
        });

      d3.select("#form-config").selectAll('.chr-box')
        .data(gffKeys)
        .on("change", function() {
          var selectedChromosomes = [];
          var visitedChr = {};
          for (var i = 0; i < gffKeys.length; i++) {
            visitedChr[gffKeys[i]] = false;
          }

          d3.selectAll(".chr-box").each(function(d) {
            d3.select(this.parentNode).classed("disabled", false);
            d3.select(this.parentNode).select('span').text(d);

            var cb = d3.select(this);
            cb.attr("disabled", null);
            if (cb.property("checked")) {
              visitedChr[d] = true; // Assume this
              selectedChromosomes.push(cb.property("value"));
            }
          });

          if (selectedChromosomes.length == 1) {
            console.log('selectedChromosomes: ', selectedChromosomes);

            for (var j = 0; j < gffKeys.length; j++) {
              if (findBlockConnection(connectionDictionary, selectedChromosomes[0], gffKeys[j])) {
                visitedChr[gffKeys[j]] = true;
              }
            }

            d3.selectAll(".chr-box").each(function(d) {
              d3.select(this.parentNode).select('span').html(function() {
                var indexConnection = findIndexConnection(connectionDictionary, selectedChromosomes[0], d);
                var connectionAmount = 0;
                var textToShow = d;
                var style = '<em style="display: inline-block; text-align: right; width: 65px; margin-left: 10px">';
                if (indexConnection === (-1)) {
                  textToShow += style + '0 blocks' + ' </em>';
                } else {
                  connectionAmount = connectionDictionary[selectedChromosomes[0]][indexConnection].blockIDs.length;
                  if (connectionAmount === 1) {
                    textToShow += style + connectionAmount + ' block' + ' </em>';
                  } else {
                    textToShow += style + connectionAmount + ' blocks' + ' </em>';
                  }
                }

                return textToShow;
              });

              if (visitedChr[d]) {
                d3.select(this).attr("disabled", null);
                d3.select(this.parentNode).classed("disabled", false);
              } else {
                d3.select(this).attr("disabled", "true");
                d3.select(this.parentNode).classed("disabled", true);
              }
            });

            console.log('VISITED CHR: ', visitedChr);
          } else if (selectedChromosomes.length > 1) {
            d3.select('p.show-all > input').property("checked", false);
          }
        });

      d3.select("#form-config").selectAll('p:not(.show-all)')
        .append('span')
        .text(function(d) {
          if (d) {
            return d.toString();
          }
        });

      d3.select("#form-config")
        .append('p')
        .append('input')
        .attr('type', 'submit');

      console.log('DICTIONARY gff: ', gffPositionDictionary);
      console.log('gene: ', geneDictionary['BnaN01g00190.1']);

      svg = d3.select("body")
        .append("div")
        .attr('id', 'chart')
        .attr("width", width)
        .attr("height", height)
        .style("float", "left");

      svg.select("svg > .all")
        .call(d3.zoom().on("zoom", function() {
          svg.select("svg > .all").attr("transform", d3.event.transform)
        }))
        .append("g");

      myCircos = new Circos({
        container: '#chart',
        width: width,
        height: height
      });

      generateGenomeView();
    }

    /**
     * [generateBlockView description]
     * @param  {[type]} data [description]
     * @return {[type]}      [description]
     */
    function generateBlockView(data) {
      // console.log('DATA in BLOCK VIEW: ', data);
      var sourceChromosomeID = data.source.id;
      var targetChromosomeID = data.target.id;
      var blockID = data.source.value.id;

      var margin = {
        top: 50,
        right: 90,
        bottom: 50,
        left: 90
      };
      var widthBlock = 500 - margin.left - margin.right;
      var heightBlock = 800 - margin.top - margin.bottom;

      // set the ranges
      var y = [];
      y.push(d3.scaleLinear().range([heightBlock, 0]));
      y.push(d3.scaleLinear().range([heightBlock, 0]));

      var x = d3.scalePoint().rangeRound([0, widthBlock]);
      var dimensions = [0, 1];
      x.domain(dimensions);

      var line = d3.line();

      // define the path
      // d3 is looping through each data array
      // p can be either 0 or 1 (the dimensions),
      // thus d[p] is the value for each dimension in the current array
      // y[p](d[p]) is scaling the current value in the dimension
      function path(d) {
        // console.log('D: ', d);
        d = d.data;
        return line(dimensions.map(function(p) {
          // console.log('DP: ', x(p), p, d[p], y[p](d[p]));
          // console.log('P: ', p, position(p), y[p](d[p]));
          return [x(p), y[p](d[p])];
        }));
      }

      d3.select("body").select('#block-view-container').remove();
      var gY0, gY1, y0axis, y1axis, isFlipped = false;
      var dataBlock = [];

      function flipTargetDataBlock(dataBlock) {
        var temp = 0;
        var tempArray = _.cloneDeep(dataBlock);

        for (var i = 0; i < tempArray.length / 2; i++) {
          temp = tempArray[i].data[1];
          tempArray[i].data[1] = tempArray[tempArray.length - i - 1].data[1];
          tempArray[tempArray.length - i - 1].data[1] = temp;
        }

        return tempArray;
      }

      function isPerfectlyFlipped(dataBlock) {
        var tempArray = _.cloneDeep(dataBlock);
        var numericGeneArray = [];

        for (var i = 0; i < tempArray.length; i++) {
          numericGeneArray.push(parseInt(tempArray[i].target.split("g")[1].split(".")[0]));
        }

        var isDescending = true;

        for (var i = 0; i < numericGeneArray.length - 1; i++) {
          if (numericGeneArray[i] < numericGeneArray[i + 1]) {
            isDescending = false;
            break;
          }
        }

        return isDescending;
      }

      // append the svg object to the body of the page
      // appends a 'group' element to 'svg'
      // moves the 'group' element to the top left margin
      var svgBlock = d3.select("body").append("div")
        .attr("id", "block-view-container")
        .style("float", "left")
        .style("margin-left", '50px')
        .append("svg")
        .attr("class", "block-view")
        .attr("width", widthBlock + margin.left + margin.right)
        .attr("height", heightBlock + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      d3.select("#block-view-container")
        .append('p')
        .style('text-align', 'right')
        .style('margin', '-30px 0 0')
        .append('input')
        .attr('class', 'flip-orientation')
        .attr('type', 'checkbox')
        .attr('name', 'flip-orientation')
        .attr('value', 'flip-orientation')
        .property('checked', false);

      d3.select("#block-view-container")
        .select('p')
        .append('span')
        .text("Flip Orientation");

      d3.select("#block-view-container")
        .append('p')
        .attr('class', 'flip-hint')
        .style('display', 'none')
        .style('margin-top', '10px')
        .html(function() {
          return '<em>Hint: This block is perfectly inverted. </em>';
        });

      d3.select("#block-view-container")
        .select('.flip-orientation')
        .on("change", function() {
          dataBlock = flipTargetDataBlock(dataBlock);
          isFlipped = d3.select(this).property("checked");

          generatePathBlockView(dataBlock);
        });

      var zoomView = svgBlock.append("g")
        .attr("class", "zoom")
        .attr("width", widthBlock)
        .attr("height", heightBlock);

      var zoom = d3.zoom()
        .scaleExtent([1, 5]) // check later
        .on("zoom", function(d) {

          //Log out d3.event.transform, so you can see all the goodies inside
          console.log(d3.event.transform);
          // console.log('RESCALE: ', d3.event.transform.rescaleY(y[1]));

          zoomView.attr("transform", d3.event.transform);
          // d3.selectAll('.line').style("stroke-width", 2/d3.event.transform.k);
          // d3.event.transform.rescaleX(x);

          if (gY0) gY0.call(y0axis.scale(d3.event.transform.rescaleY(y[0])));
          if (gY1) gY1.call(y1axis.scale(d3.event.transform.rescaleY(y[1])));

          if (gY0 && gY1) {
            //svgBlock.selectAll("path")
            //  .data(dataBlock)
            //  .attr("d", path);
          }
        });

      svgBlock.call(zoom)
        .call(zoom.transform, d3.zoomIdentity
          .translate(margin.left, margin.top)
        );

      var blockArray = blockDictionary[blockID];
      console.log('Block Dictionary: ', blockArray);

      for (var i = 0; i < blockArray.length; i++) {
        var blockSource = blockArray[i].source;
        var blockTarget = blockArray[i].target;
        var currentSource = geneDictionary[blockSource];
        var currentTarget = geneDictionary[blockTarget];
        // console.log('SOURCE: ', currentSource, currentTarget);
        var currentData = [
          (currentSource.start + currentSource.end) / 2,
          (currentTarget.start + currentTarget.end) / 2
        ];
        // console.log('CURRENT DATA: ', currentData);
        dataBlock.push({
          source: blockSource,
          target: blockTarget,
          data: currentData
        });
      }

      // Mockup data
      /*dataBlock = [{
          source: 1,
          target: 2,
          data: [58.13, 9.8]
        },
        {
          source: 1,
          target: 2,
          data: [130.28, 3.41]
        },
        {
          source: 1,
          target: 2,
          data: [40, 5]
        },
        {
          source: 1,
          target: 2,
          data: [31.5, 17.7]
        },
        {
          source: 1,
          target: 2,
          data: [31.5, 20]
        }
      ];*/

      /*
        Mockup data with target flipped:

        58.13 -> 20
        130.28 -> 17.7
        40 -> 5
        31.5 -> 3.41
        31.5 9.8
       */

      function generatePathBlockView(dataBlock) {
        var d3Element = d3.select("#block-view-container")
          .select(".flip-hint");

        if (!isFlipped) {
          if (isPerfectlyFlipped(dataBlock)) {
            // Show hint: display block
            d3Element.style('display', 'block');
          }
        } else {
          d3Element.style('display', 'none');
        }

        function minData(d) {
          var minValue = 100000000;
          for (var i = 0; i < dataBlock.length; i++) {
            minValue = Math.min(minValue, dataBlock[i].data[d]);
          }
          return minValue;
        }

        function maxData(d) {
          var maxValue = 0;
          for (var i = 0; i < dataBlock.length; i++) {
            maxValue = Math.max(maxValue, dataBlock[i].data[d]);
          }
          return maxValue;
        }

        var offset = 50000;
        // console.log('VALUES: ', minData(0), maxData(0), minData(1), maxData(1));
        y[0].domain([minData(0) - offset, maxData(0) + offset]);
        y[1].domain([minData(1) - offset, maxData(1) + offset]);

        /* Using chromosome domains: NO, too clutered */
        /*Trying zooming with this? */
        /*y[0].domain([
          gffPositionDictionary[sourceChromosomeID].start,
          gffPositionDictionary[sourceChromosomeID].end
        ]);

        y[1].domain([
          gffPositionDictionary[targetChromosomeID].start,
          gffPositionDictionary[targetChromosomeID].end
        ]);*/

        // Add the valueline path.
        svgBlock.selectAll("path").remove();

        svgBlock.selectAll("path")
          .data(dataBlock).enter()
          .append("g")
          .append("path")
          .attr("class", "line")
          .attr("d", path)
          .attr("stroke-width", 2)
          .append("title")
          .text(function(d) {
            return d.source + ' ➤ ' + d.target;
          });

        svgBlock.selectAll("path")
          .on("mouseover", function(d, i, nodes) {
            if (d3.selectAll(nodes).attr("opacity") != 0.35) {
              d3.selectAll(nodes).attr("opacity", 0.35);
              d3.select(nodes[i]).attr("opacity", 1);
            }
            // console.log("CLICK: ", d.source, d.target);
          })
          .on("mouseout", function(d, i, nodes) {
            if (d3.selectAll(nodes).attr("opacity") != 1) {
              d3.selectAll(nodes).attr("opacity", 1);
            }
          });

        // Add the Y0 Axis
        y0axis = d3.axisLeft(y[0]);
        svgBlock.selectAll("g.axisBlue").remove();
        gY0 = svgBlock.append("g")
          .attr("class", "axisBlue")
          .call(y0axis.ticks(8));

        // Add the Y1 Axis
        y1axis = d3.axisRight(y[1]);
        svgBlock.selectAll("g.axisGreen").remove();
        gY1 = svgBlock.append("g")
          .attr("class", "axisGreen")
          .attr("transform", "translate( " + widthBlock + ", 0 )")
          .call(y1axis.ticks(8));
      }

      generatePathBlockView(dataBlock);

      // Add the Y0 Axis label text
      svgBlock.append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", 0 - margin.left)
        .attr("x", 0 - (heightBlock / 2))
        .attr("dy", "1em")
        .style("font-size", "16px")
        .style("text-anchor", "middle")
        .text(sourceChromosomeID);

      // Add the Y1 Axis label text
      svgBlock.append("text")
        .attr("transform", "rotate(90)")
        .attr("y", 0 - widthBlock - margin.right)
        .attr("x", (heightBlock / 2))
        .attr("dy", "1em")
        .style("font-size", "16px")
        .style("text-anchor", "middle")
        .text(targetChromosomeID);

      // Add the Chart title
      svgBlock.append("text")
        .attr("x", (widthBlock / 2))
        .attr("y", 0 - (margin.top / 3))
        .attr("text-anchor", "middle")
        .style("font-size", "16px")
        .style("text-decoration", "underline")
        .text(sourceChromosomeID + ' vs. ' + targetChromosomeID + ' - Block ' + blockID);
    }

    /**
     * [generateGenomeView description]
     * @return {[type]} [description]
     */
    function generateGenomeView() {
      // Remove block view if it is present
      d3.select("body").select('#block-view-container').remove();

      if (selectedCheckbox.length < 1) {
        selectedCheckbox = ["N1"]; // Including N1 as default here
      }

      var data = [];
      var colors = d3.scaleOrdinal(d3.schemeAccent);

      gffKeys.forEach(function(key, i) {
        // TODO: Add select all button
        if (gffPositionDictionary.hasOwnProperty(key)) {
          var currentObj = {
            len: gffPositionDictionary[key].end,
            color: colors(i),
            label: key,
            id: key
          };

          if (showAllChromosomes) {
            data.push(currentObj);
          } else {
            if (selectedCheckbox.indexOf(key) > -1) {
              data.push(currentObj);
            }
          }
        }
      });

      console.log('DATA: ', data);

      var configuration = {
        innerRadius: 300,
        outerRadius: 350,
        cornerRadius: 1,
        gap: data.length === 1 ? 0 : 0.04, // in radian
        labels: {
          display: true,
          position: 'center',
          size: '16px',
          color: '#000000',
          radialOffset: 20,
        },
        ticks: {
          display: false
        },
        events: {
          'click.chromosome': function(d, i, nodes, event) {
            // TODO: Remove this
            if (d3.select(nodes[i]).attr("opacity") == 0.5) {
              d3.select(nodes[i]).attr("opacity", 1);
            } else {
              d3.selectAll(nodes).attr("opacity", 1);
              d3.select(nodes[i]).attr("opacity", 0.5);
            }

            var trackContainers = myCircos.svg.selectAll('.all > g');

            // console.log('CONTAINERS: ', trackContainers);

            /*myCircos.svg.selectAll('tile')
              .data((d) => {
                console.log(d);
              })
              .enter().append('path')
              .attr('class', 'tile')
              .attr('d', function (d) {
                  console.log('D here: ', d);
              })*/
            //d.len = 200;
            console.log('clicked on layout block', d, i, nodes[i], event);
          }
        }
      };

      myCircos.layout(data, configuration);

      dataChords = [];

      function lookForBlocksPositions(block) {
        var blockArray = blockDictionary[block];
        // TODO: Another way to declare these?
        var maxSource = 0;
        var minSource = 100000000;
        var maxTarget = 0;
        var minTarget = 100000000;
        for (var i = 0; i < blockArray.length; i++) {
          var currentSource = geneDictionary[blockArray[i].source];
          var currentTarget = geneDictionary[blockArray[i].target];

          minSource = Math.min(minSource, currentSource.start);
          maxSource = Math.max(maxSource, currentSource.end);

          minTarget = Math.min(minTarget, currentTarget.start);
          maxTarget = Math.max(maxTarget, currentTarget.end);
        }

        return {
          blockLength: blockArray.length,
          minSource: minSource,
          maxSource: maxSource,
          minTarget: minTarget,
          maxTarget: maxTarget
        }
      }

      console.log(lookForBlocksPositions(45));

      console.log(selectedCheckbox);
      var visited = []; // TODO: Fix this
      for (var i = 0; i < 1500; i++) {
        visited.push(false);
      }

      var oneToMany = selectedCheckbox.length == 1;
      var lookID = [];
      if (oneToMany) {
        lookID.push(selectedCheckbox[0]);
      } else {
        for (var j = 0; j < selectedCheckbox.length; j++) {
          lookID.push(selectedCheckbox[j]);
        }
      }

      for (var i = 0; i < collinearityFile.length; i++) {
        if (collinearityFile[i].source.includes('N') && collinearityFile[i].target.includes('N')) {

          var IDs = fixSourceTargetCollinearity(collinearityFile, i);
          var sourceID = IDs.source;
          var targetID = IDs.target;

          var shouldAddDataChord = false;
          if (oneToMany) {
            shouldAddDataChord = showAllChromosomes ?
              (lookID.indexOf(sourceID) > -1 || lookID.indexOf(targetID) > -1) :
              (lookID.indexOf(sourceID) > -1 && lookID.indexOf(targetID) > -1);
          } else {
            shouldAddDataChord = lookID.indexOf(sourceID) > -1 && lookID.indexOf(targetID) > -1;
          }

          var currentBlock = collinearityFile[i].block;
          if (!visited[currentBlock]) {
            var blockPositions = lookForBlocksPositions(currentBlock);

            visited[currentBlock] = true;
            if (shouldAddDataChord) {
              dataChords.push({
                source: {
                  id: sourceID,
                  start: blockPositions.minSource,
                  end: blockPositions.maxSource,
                  value: {
                    id: currentBlock,
                    length: blockPositions.blockLength,
                  }
                },
                target: {
                  id: targetID,
                  start: blockPositions.minTarget,
                  end: blockPositions.maxTarget
                }
              });
            }
          }
        }
      }

      console.log('DATA CHORDS: ', dataChords.length);

      myCircos.chords('chords', dataChords, {
        radius: function(d) {
          return null;
        },
        logScale: false,
        opacity: 0.7,
        color: function(d) {
          /*if (d.source.value) {
            return d.source.value;
          } else*/
          return '#ff5722';
        },
        tooltipContent: function(d) {
          return '<h4>' + d.source.id + ' ➤ ' + d.target.id + '</h4>' +
            '<h4><u>Block information</u></h4>' +
            '<h4>ID: ' + d.source.value.id + '</h4>' +
            '<h4>Length: ' + d.source.value.length + '</h4>';
        },
        events: {
          'mouseover.block': function(d, i, nodes, event) {
            // console.log('MOUSEOVER: ', nodes[i]);
            // console.log('MOUSEOVER: ', d, i, nodes, event);

            d3.selectAll(nodes).attr("opacity", 0.7);

            if (d3.selectAll(nodes).attr("opacity") != 0.35) {
              d3.selectAll(nodes).attr("opacity", 0.35);
              d3.select(nodes[i]).attr("opacity", 0.9);
            }

            generateBlockView(d);
          },
          'click.block': function(d, i, nodes, event) {
            // TODO: Remove this
          }
        }
      });

      myCircos.render();

      /*svg.select(".all")
        .on("scroll", function(d) {
          console.log('hello: ', d);
        })*/

      d3.select("#nAngle").on("input", function() {
        update(+this.value);
      });

      // Initial starting angle of the text
      update(0);

      // update the element
      function update(nAngle) {

        // adjust the text on the range slider
        d3.select("#nAngle-value").text(nAngle + String.fromCharCode(176));
        d3.select("#nAngle").property("value", nAngle);

        // rotate the text
        svg.select(".all")
          .attr("transform", "translate(" + width / 2 + "," + height / 2 + ") rotate(" + -nAngle + ")");
      }
    }

    d3.queue()
      .defer(d3.csv, './files/gff.csv')
      .defer(d3.csv, './files/collinearity.csv')
      .await(generateData)
  </script>
</body>

</html>
